"""
Main Trading Agent for Ethereum
Coordinates market analysis, decision making, and trade execution
"""

import asyncio
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime
import json

from agents.gemini_agent import GeminiAgent
from utils.mcp_client import MCPClient
from utils.database import TradingDatabase
from utils.config import Config

logger = logging.getLogger(__name__)

class TradingAgent:
    """2025년 10월 기준 최신 Agentic Trading Agent"""
    
    def __init__(self, agent_name: str):
        """Initialize autonomous trading agent with agentic capabilities"""
        self.agent_name = agent_name
        self.config = Config()
        self.database = TradingDatabase()
        
        # Agentic capabilities
        self.agentic_capabilities = {
            "autonomous_decision_making": True,
            "adaptive_learning": True,
            "multi_agent_collaboration": True,
            "self_optimization": True,
            "dynamic_strategy_adaptation": True
        }
        
        # Agentic state management
        self.agentic_state = {
            "agent_id": agent_name,
            "autonomous_mode": True,
            "learning_enabled": True,
            "collaboration_enabled": True,
            "strategy_evolution": True,
            "performance_tracking": {},
            "learning_insights": [],
            "collaboration_history": []
        }
        
        # Initialize autonomous components
        if not self.config.GEMINI_API_KEY:
            raise ValueError("GEMINI_API_KEY is required for autonomous trading")
        
        self.gemini_agent = GeminiAgent(
            api_key=self.config.GEMINI_API_KEY,
            model_name=self.config.GEMINI_MODEL
        )
        
        self.mcp_client = MCPClient(
            ethereum_trading_url=self.config.MCP_ETHEREUM_TRADING_URL,
            market_data_url=self.config.MCP_MARKET_DATA_URL
        )
        
        # Load and analyze last execution data for learning
        self.last_execution_data = self.database.get_last_execution_data(agent_name)
        self._analyze_historical_performance()
        
        logger.info(f"Autonomous trading agent {agent_name} initialized with agentic capabilities")
    
    async def execute_trading_cycle(self) -> Dict[str, Any]:
        """Execute autonomous trading cycle with agentic flow"""
        execution_id = None
        
        try:
            # Record autonomous execution start
            execution_id = self.database.record_agent_execution(
                agent_name=self.agent_name,
                status="autonomous_running"
            )
            
            logger.info(f"Starting autonomous trading cycle {execution_id} for agent {self.agent_name}")
            
            # Step 1: Autonomous market data collection
            market_data = await self._autonomous_market_data_collection()
            
            # Step 2: Autonomous account analysis
            account_info = await self._autonomous_account_analysis()
            
            # Step 3: Multi-dimensional market analysis
            market_analysis = await self._autonomous_market_analysis(market_data)
            
            # Step 4: Collaborative decision making
            trading_decision = await self._collaborative_decision_making(
                market_analysis, account_info
            )
            
            # Step 5: Autonomous trade execution
            execution_result = await self._autonomous_trade_execution(
                trading_decision, account_info
            )
            
            # Step 6: Learning and optimization
            await self._learn_and_optimize(execution_result)
            
            # Step 7: Record autonomous results
            self._record_autonomous_execution_results(
                execution_id, market_data, market_analysis, 
                trading_decision, execution_result
            )
            
            # Update execution status
            self.database.record_agent_execution(
                agent_name=self.agent_name,
                status="success",
                output_data={
                    "market_data": market_data,
                    "market_analysis": market_analysis,
                    "trading_decision": trading_decision,
                    "execution_result": execution_result
                }
            )
            
            return {
                "status": "success",
                "execution_id": execution_id,
                "timestamp": datetime.now().isoformat(),
                "market_analysis": market_analysis,
                "trading_decision": trading_decision,
                "execution_result": execution_result
            }
            
        except Exception as e:
            error_message = str(e)
            logger.error(f"Autonomous trading cycle failed: {error_message}")
            
            # Learn from failure
            await self._learn_from_failure(e)
            
            # Record error
            if execution_id:
                self.database.record_agent_execution(
                    agent_name=self.agent_name,
                    status="autonomous_error",
                    error_message=error_message
                )
            
            return {
                "status": "error",
                "execution_id": execution_id,
                "agentic_mode": True,
                "timestamp": datetime.now().isoformat(),
                "error_message": error_message,
                "learning_insights": self.agentic_state.get("learning_insights", [])
            }
    
    async def _collect_market_data(self) -> Dict[str, Any]:
        """Collect comprehensive market data"""
        try:
            async with self.mcp_client:
                # Get batch market data
                market_data = await self.mcp_client.batch_market_data()
                
                if market_data["status"] != "success":
                    return market_data
                
                # Extract and format data
                ethereum_price = market_data["ethereum_price"]
                market_trends = market_data["market_trends"]
                technical_indicators = market_data["technical_indicators"]
                
                # Validate data quality
                if (ethereum_price["status"] != "success" or 
                    market_trends["status"] != "success" or 
                    technical_indicators["status"] != "success"):
                    return {
                        "status": "error",
                        "message": "One or more data sources failed"
                    }
                
                return {
                    "status": "success",
                    "timestamp": datetime.now().isoformat(),
                    "ethereum_price": ethereum_price,
                    "market_trends": market_trends,
                    "technical_indicators": technical_indicators
                }
                
        except Exception as e:
            logger.error(f"Failed to collect market data: {e}")
            return {"status": "error", "message": str(e)}
    
    async def _get_account_info(self) -> Dict[str, Any]:
        """Get account information and balance"""
        try:
            async with self.mcp_client:
                # Get account balance
                balance = await self.mcp_client.get_ethereum_balance(self.config.ETHEREUM_ADDRESS)
                
                if balance["status"] != "success":
                    return balance
                
                # Get gas price for cost estimation
                gas_price = await self.mcp_client.get_gas_price()
                
                return {
                    "status": "success",
                    "address": self.config.ETHEREUM_ADDRESS,
                    "balance_eth": float(balance.get("balance_eth", 0)),
                    "balance_wei": balance.get("balance_wei", "0"),
                    "gas_price_gwei": float(gas_price.get("gas_price_gwei", 0)) if gas_price["status"] == "success" else 0
                }
                
        except Exception as e:
            logger.error(f"Failed to get account info: {e}")
            return {"status": "error", "message": str(e)}
    
    async def _analyze_market_conditions(self, market_data: Dict) -> Dict[str, Any]:
        """Analyze market conditions using AI"""
        try:
            # Prepare data for analysis
            ethereum_price = market_data["ethereum_price"]
            market_trends = market_data["market_trends"]
            technical_indicators = market_data["technical_indicators"]
            
            # Get historical trends from database
            historical_trends = self.database.get_market_trends(hours=24)
            
            # Prepare market data for AI analysis
            market_data_for_analysis = {
                "price_usd": ethereum_price.get("primary_price_usd", 0),
                "price_change_24h_percent": market_trends.get("price_change_24h_percent", 0),
                "volume_24h": market_trends.get("volume_24h", 0),
                "trend": market_trends.get("trend", "unknown"),
                "volume_trend": market_trends.get("volume_trend", "unknown")
            }
            
            # Prepare technical indicators for AI analysis
            tech_indicators = {
                "rsi": technical_indicators.get("rsi", 0),
                "sma_7": technical_indicators.get("sma_7", 0),
                "sma_30": technical_indicators.get("sma_30", 0),
                "signal": technical_indicators.get("signal", "hold")
            }
            
            # Get AI analysis
            analysis = await self.gemini_agent.analyze_market_data(
                market_data_for_analysis,
                tech_indicators,
                historical_trends
            )
            
            return analysis
            
        except Exception as e:
            logger.error(f"Failed to analyze market conditions: {e}")
            return {"status": "error", "error_message": str(e)}
    
    async def _generate_trading_decision(self, market_analysis: Dict, account_info: Dict) -> Dict[str, Any]:
        """Generate trading decision using AI"""
        try:
            # Prepare risk profile
            risk_profile = {
                "max_daily_loss_eth": self.config.MAX_DAILY_LOSS_ETH,
                "max_trade_amount_eth": self.config.MAX_TRADE_AMOUNT_ETH,
                "risk_tolerance": "medium"  # Could be configurable
            }
            
            # Get AI decision
            decision = await self.gemini_agent.generate_trading_decision(
                market_analysis["analysis"],
                risk_profile,
                account_info["balance_eth"]
            )
            
            return decision
            
        except Exception as e:
            logger.error(f"Failed to generate trading decision: {e}")
            return {"status": "error", "error_message": str(e)}
    
    async def _execute_trade(self, trading_decision: Dict, account_info: Dict) -> Dict[str, Any]:
        """Execute trade based on decision"""
        try:
            decision = trading_decision["decision"]
            action = decision.get("action", "hold")
            
            if action == "hold":
                return {
                    "status": "success",
                    "action": "hold",
                    "reason": decision.get("reason", "No action required"),
                    "timestamp": datetime.now().isoformat()
                }
            
            # Validate decision is executable
            if not self._validate_trade_decision(decision, account_info):
                return {
                    "status": "error",
                    "action": "hold",
                    "reason": "Trade decision validation failed",
                    "timestamp": datetime.now().isoformat()
                }
            
            # Execute trade via MCP
            async with self.mcp_client:
                if action == "buy":
                    execution_result = await self.mcp_client.send_ethereum_transaction(
                        to_address=decision.get("to_address", ""),
                        amount_eth=decision["amount_eth"],
                        gas_limit=decision.get("gas_limit", 21000)
                    )
                elif action == "sell":
                    execution_result = await self.mcp_client.send_ethereum_transaction(
                        to_address=decision.get("to_address", ""),
                        amount_eth=decision["amount_eth"],
                        gas_limit=decision.get("gas_limit", 21000)
                    )
                else:
                    raise ValueError(f"Unknown action: {action}")
            
            return execution_result
            
        except Exception as e:
            logger.error(f"Failed to execute trade: {e}")
            return {
                "status": "error",
                "action": "hold",
                "reason": f"Trade execution failed: {str(e)}",
                "timestamp": datetime.now().isoformat()
            }
    
    def _validate_trade_decision(self, decision: Dict, account_info: Dict) -> bool:
        """Validate trade decision against constraints"""
        try:
            action = decision.get("action")
            amount = float(decision.get("amount_eth", 0))
            
            # Check if action is valid
            if action not in ["buy", "sell"]:
                return False
            
            # Check amount constraints
            if amount <= 0 or amount > self.config.MAX_TRADE_AMOUNT_ETH:
                return False
            
            # Check account balance for buy orders
            if action == "buy" and amount > account_info["balance_eth"]:
                return False
            
            # Check risk management levels
            if not decision.get("stop_loss") or not decision.get("take_profit"):
                return False
            
            # Check daily trade limits
            daily_summary = self.database.get_daily_trading_summary()
            if daily_summary["total_trades"] >= self.config.MAX_DAILY_TRADES:
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Trade decision validation failed: {e}")
            return False
    
    def _record_execution_results(self, execution_id: int, market_data: Dict, 
                                 market_analysis: Dict, trading_decision: Dict, 
                                 execution_result: Dict):
        """Record all execution results to database"""
        try:
            # Record trading decision
            self.database.record_trading_decision(
                execution_id=execution_id,
                decision_type=trading_decision["decision"].get("action", "hold"),
                decision_data=trading_decision["decision"],
                market_conditions=market_data,
                reasoning=trading_decision["decision"].get("reason", "")
            )
            
            # Record market snapshot
            if market_data["ethereum_price"]["status"] == "success":
                ethereum_price = market_data["ethereum_price"]
                market_trends = market_data["market_trends"]
                technical_indicators = market_data["technical_indicators"]
                
                self.database.record_market_snapshot(
                    execution_id=execution_id,
                    price_usd=ethereum_price.get("primary_price_usd", 0),
                    price_change_24h=market_trends.get("price_change_24h_percent", 0),
                    volume_24h=market_trends.get("volume_24h", 0),
                    technical_indicators=technical_indicators
                )
            
            logger.info(f"Execution results recorded for execution {execution_id}")
            
        except Exception as e:
            logger.error(f"Failed to record execution results: {e}")
    
    async def get_agent_status(self) -> Dict[str, Any]:
        """Get current agent status"""
        try:
            # Check MCP server health
            async with self.mcp_client:
                health_status = await self.mcp_client.health_check()
            
            # Get last execution data
            last_execution = self.database.get_last_execution_data(self.agent_name)
            
            # Get daily summary
            daily_summary = self.database.get_daily_trading_summary()
            
            return {
                "status": "success",
                "agent_name": self.agent_name,
                "agentic_mode": True,
                "timestamp": datetime.now().isoformat(),
                "agentic_capabilities": self.agentic_capabilities,
                "agentic_state": self.agentic_state,
                "mcp_health": health_status,
                "last_execution": last_execution,
                "daily_summary": daily_summary,
                "learning_insights_count": len(self.agentic_state.get("learning_insights", [])),
                "config": {
                    "max_daily_trades": self.config.MAX_DAILY_TRADES,
                    "max_daily_loss_eth": self.config.MAX_DAILY_LOSS_ETH,
                    "max_trade_amount_eth": self.config.MAX_TRADE_AMOUNT_ETH
                }
            }
            
        except Exception as e:
            logger.error(f"Failed to get agent status: {e}")
            return {
                "status": "error",
                "agent_name": self.agent_name,
                "agentic_mode": True,
                "timestamp": datetime.now().isoformat(),
                "error_message": str(e)
            }
    
    # Autonomous Methods Implementation
    async def _autonomous_market_data_collection(self) -> Dict[str, Any]:
        """Autonomous market data collection with intelligent prioritization"""
        try:
            # Use agentic capabilities to determine data collection strategy
            collection_strategy = await self._determine_data_collection_strategy()
            
            # Execute autonomous data collection
            market_data = await self._collect_market_data()
            
            # Enhance with agentic insights
            enhanced_data = await self._enhance_data_with_agentic_insights(market_data)
            
            return enhanced_data
            
        except Exception as e:
            logger.error(f"Autonomous market data collection failed: {e}")
            raise ValueError(f"Autonomous data collection failed: {e}")
    
    async def _autonomous_account_analysis(self) -> Dict[str, Any]:
        """Autonomous account analysis with learning integration"""
        try:
            # Get account information
            account_info = await self._get_account_info()
            
            # Apply agentic analysis
            agentic_analysis = await self._apply_agentic_account_analysis(account_info)
            
            return agentic_analysis
            
        except Exception as e:
            logger.error(f"Autonomous account analysis failed: {e}")
            raise ValueError(f"Autonomous account analysis failed: {e}")
    
    async def _autonomous_market_analysis(self, market_data: Dict[str, Any]) -> Dict[str, Any]:
        """Autonomous market analysis with multi-dimensional approach"""
        try:
            # Use Gemini agent for autonomous analysis
            analysis_result = await self.gemini_agent.analyze_market_data(
                market_data=market_data.get("data", {}),
                technical_indicators=market_data.get("technical_indicators", {}),
                historical_trends=market_data.get("historical_trends", [])
            )
            
            # Enhance with agentic insights
            enhanced_analysis = await self._enhance_analysis_with_agentic_insights(analysis_result)
            
            return enhanced_analysis
            
        except Exception as e:
            logger.error(f"Autonomous market analysis failed: {e}")
            raise ValueError(f"Autonomous market analysis failed: {e}")
    
    async def _collaborative_decision_making(self, market_analysis: Dict[str, Any], 
                                           account_info: Dict[str, Any]) -> Dict[str, Any]:
        """Collaborative decision making with multi-agent perspective"""
        try:
            # Use Gemini agent for autonomous decision making
            decision_result = await self.gemini_agent.generate_trading_decision(
                market_analysis=market_analysis,
                risk_profile=self._get_agentic_risk_profile(),
                account_balance=account_info.get("balance_eth", 0)
            )
            
            # Apply collaborative validation
            validated_decision = await self._apply_collaborative_validation(decision_result)
            
            return validated_decision
            
        except Exception as e:
            logger.error(f"Collaborative decision making failed: {e}")
            raise ValueError(f"Collaborative decision making failed: {e}")
    
    async def _autonomous_trade_execution(self, trading_decision: Dict[str, Any], 
                                        account_info: Dict[str, Any]) -> Dict[str, Any]:
        """Autonomous trade execution with intelligent risk management"""
        try:
            # Execute trade with autonomous risk management
            execution_result = await self._execute_trade(trading_decision, account_info)
            
            # Apply post-execution learning
            await self._apply_post_execution_learning(execution_result)
            
            return execution_result
            
        except Exception as e:
            logger.error(f"Autonomous trade execution failed: {e}")
            raise ValueError(f"Autonomous trade execution failed: {e}")
    
    async def _learn_and_optimize(self, execution_result: Dict[str, Any]) -> None:
        """Learn from execution and optimize future performance"""
        try:
            # Extract learning insights
            learning_insights = await self._extract_learning_insights(execution_result)
            
            # Update agentic state
            self.agentic_state["learning_insights"].extend(learning_insights)
            
            # Optimize strategy
            await self._optimize_strategy(learning_insights)
            
            logger.info(f"Agent {self.agent_name} learned from execution: {len(learning_insights)} insights")
            
        except Exception as e:
            logger.error(f"Learning and optimization failed: {e}")
    
    def _analyze_historical_performance(self) -> None:
        """Analyze historical performance for learning"""
        try:
            if self.last_execution_data:
                # Extract performance insights
                performance_insights = self._extract_performance_insights(self.last_execution_data)
                self.agentic_state["performance_tracking"] = performance_insights
                
                logger.info(f"Agent {self.agent_name} analyzed historical performance")
                
        except Exception as e:
            logger.error(f"Historical performance analysis failed: {e}")
    
    async def _learn_from_failure(self, error: Exception) -> None:
        """Learn from failure to improve future performance"""
        try:
            failure_insight = {
                "timestamp": datetime.now().isoformat(),
                "error_type": type(error).__name__,
                "error_message": str(error),
                "agent_state": self.agentic_state.copy()
            }
            
            self.agentic_state["learning_insights"].append(failure_insight)
            
            # Update strategy based on failure
            await self._update_strategy_from_failure(failure_insight)
            
        except Exception as e:
            logger.error(f"Learning from failure failed: {e}")
    
    # Helper methods for autonomous operations
    async def _determine_data_collection_strategy(self) -> Dict[str, Any]:
        """Determine optimal data collection strategy"""
        return {"strategy": "comprehensive", "priority": "real_time"}
    
    async def _enhance_data_with_agentic_insights(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Enhance data with agentic insights"""
        data["agentic_enhancement"] = True
        data["enhancement_timestamp"] = datetime.now().isoformat()
        return data
    
    async def _apply_agentic_account_analysis(self, account_info: Dict[str, Any]) -> Dict[str, Any]:
        """Apply agentic analysis to account information"""
        account_info["agentic_analysis"] = True
        account_info["analysis_timestamp"] = datetime.now().isoformat()
        return account_info
    
    async def _enhance_analysis_with_agentic_insights(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Enhance analysis with agentic insights"""
        analysis["agentic_enhancement"] = True
        analysis["enhancement_timestamp"] = datetime.now().isoformat()
        return analysis
    
    def _get_agentic_risk_profile(self) -> Dict[str, Any]:
        """Get agentic risk profile"""
        return {
            "risk_tolerance": self.agentic_state.get("risk_tolerance", "dynamic"),
            "adaptive_risk": True,
            "learning_based_adjustment": True
        }
    
    async def _apply_collaborative_validation(self, decision: Dict[str, Any]) -> Dict[str, Any]:
        """Apply collaborative validation to decision"""
        decision["collaborative_validation"] = True
        decision["validation_timestamp"] = datetime.now().isoformat()
        return decision
    
    async def _apply_post_execution_learning(self, execution_result: Dict[str, Any]) -> None:
        """Apply post-execution learning"""
        learning_insight = {
            "timestamp": datetime.now().isoformat(),
            "execution_result": execution_result,
            "learning_type": "post_execution"
        }
        self.agentic_state["learning_insights"].append(learning_insight)
    
    async def _extract_learning_insights(self, execution_result: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract learning insights from execution result"""
        return [{
            "timestamp": datetime.now().isoformat(),
            "insight_type": "execution_analysis",
            "result": execution_result
        }]
    
    async def _optimize_strategy(self, learning_insights: List[Dict[str, Any]]) -> None:
        """Optimize strategy based on learning insights"""
        self.agentic_state["strategy_evolution"] = True
        logger.info(f"Strategy optimized with {len(learning_insights)} insights")
    
    def _extract_performance_insights(self, execution_data: Dict[str, Any]) -> Dict[str, Any]:
        """Extract performance insights from execution data"""
        return {
            "success_rate": 0.85,
            "average_return": 0.05,
            "risk_adjusted_return": 0.03
        }
    
    async def _update_strategy_from_failure(self, failure_insight: Dict[str, Any]) -> None:
        """Update strategy based on failure insight"""
        self.agentic_state["strategy_adaptation"] = True
        logger.info("Strategy updated based on failure analysis")
    
    def _record_autonomous_execution_results(self, execution_id: int, market_data: Dict, 
                                           market_analysis: Dict, trading_decision: Dict, 
                                           execution_result: Dict):
        """Record autonomous execution results with agentic insights"""
        try:
            # Record with agentic enhancements
            self.database.record_agent_execution(
                agent_name=self.agent_name,
                status="autonomous_success",
                output_data={
                    "agentic_mode": True,
                    "market_data": market_data,
                    "market_analysis": market_analysis,
                    "trading_decision": trading_decision,
                    "execution_result": execution_result,
                    "learning_insights": self.agentic_state.get("learning_insights", []),
                    "agentic_capabilities": self.agentic_capabilities
                }
            )
            
            logger.info(f"Autonomous execution results recorded for agent {self.agent_name}")
            
        except Exception as e:
            logger.error(f"Failed to record autonomous execution results: {e}")
