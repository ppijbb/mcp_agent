# 테이블게임 메이트 에이전트 시스템 개발 기획서

## 1. 프로젝트 개요

### 1.1 프로젝트 목표
범용적이고 확장 가능한 테이블게임 메이트 에이전트 시스템을 구축하여 사용자가 다양한 보드게임을 AI 플레이어들과 함께 즐길 수 있는 환경을 제공합니다.

### 1.2 핵심 특징
- **범용성**: 특정 게임이 아닌 모든 테이블탑 보드게임 지원
- **동적 게임 분석**: 실시간 게임 규칙 검색 및 분석
- **유동적 플레이어 생성**: 게임에 맞춘 AI 플레이어 동적 생성
- **페르소나 시스템**: 게임별 특화된 AI 성격 부여
- **사용자 참여**: 채팅을 통한 실시간 게임 참여

## 2. 기술 스택 분석 및 선택

### 2.1 아키텍처 선택: LangGraph vs MCP
조사 결과를 바탕으로 **LangGraph + MCP 하이브리드 아키텍처**를 채택합니다.

#### 🤖 진짜 Agent의 정의 (2025년 기준)
- **Perception (인식)**: 환경을 감지하고 데이터를 수집
- **Reasoning (추론)**: LLM 기반 복잡한 논리적 사고와 계획 수립
- **Action (행동)**: 목표 달성을 위한 실제 행동 실행
- **Learning (학습)**: 경험을 통한 지속적 개선
- **Autonomy (자율성)**: 최소한의 인간 개입으로 독립적 작업

#### LangGraph 선택 이유:
- **상태 관리**: 복잡한 게임 상태를 안정적으로 관리
- **에이전트 오케스트레이션**: 다중 에이전트 시스템에 최적화
- **실시간 상호작용**: 스트리밍 지원으로 실시간 게임 진행 가능
- **디버깅 및 관찰**: 게임 진행 과정 추적 및 디버깅 용이
- **서브그래프**: 모듈화된 에이전트 시스템 구축 가능

#### ❌ 피해야 할 "가짜 Agent" 패턴
- 단순한 if-else 분기문
- 하드코딩된 응답
- 폴백만 들어가있는 TODO 형 코드드
- 상태 머신만으로 구성된 시스템
- LLM 없는 규칙 기반 시스템

#### MCP 통합 이유:
- **외부 데이터 접근**: BoardGameGeek API, 웹 검색 등
- **파일시스템 접근**: 게임 규칙 문서 관리
- **데이터베이스 연동**: 게임 기록 및 사용자 데이터 저장

### 2.2 핵심 MCP 서버 활용

#### 데이터 수집용 MCP 서버:
1. **Brave Search MCP**: 게임 규칙 검색
2. **Fetch MCP**: 웹 콘텐츠 수집 및 변환
3. **Filesystem MCP**: 로컬 게임 데이터 관리
4. **BGG API 커스텀 MCP**: BoardGameGeek 데이터 접근

#### 운영 지원용 MCP 서버:
1. **Memory MCP**: 게임별 지식 그래프 관리
2. **SQLite MCP**: 게임 기록 및 통계 저장
3. **Time MCP**: 게임 시간 관리

### 2.3 보드게임 데이터 소스

#### BoardGameGeek XML API 2 활용:
- **게임 정보**: `/xmlapi2/thing` - 게임 상세 정보, 규칙, 메타데이터
- **검색 기능**: `/xmlapi2/search` - 게임명 기반 검색
- **사용자 데이터**: `/xmlapi2/collection` - 사용자 게임 컬렉션
- **핫 아이템**: `/xmlapi2/hot` - 인기 게임 추천

#### 게임 엔진 라이브러리:
- **boardgame.io**: 턴 기반 게임 상태 관리
- **board-state**: 숨겨진 정보가 있는 게임 지원
- **game-state-machine**: 게임 규칙 상태 머신

### 2.1 핵심 기술 스택
```yaml
LLM: 
  - Primary: Gemini 2.5 Flash Lite Preview
  - Fallback: Claude 3.5 Sonnet
  
Framework:
  - LangGraph: 멀티 에이전트 오케스트레이션
  - LangChain: LLM 통합 및 도구 연동
  
Data Access:
  - MCP 서버: 외부 데이터 접근
  - BoardGameGeek API: 게임 정보
  - Web Search: 실시간 규칙 검색
  
Storage:
  - SQLite: 게임 기록 및 사용자 데이터
  - Memory: 세션별 상태 관리
  
Interface:
  - Streamlit: 웹 인터페이스
  - FastAPI: API 서버 (선택사항)
```
### 2.2 MCP 서버 구성
```yaml
필수 MCP 서버:
  - brave-search: 웹 검색
  - fetch: 웹 콘텐츠 수집
  - filesystem: 로컬 파일 관리
  - sqlite: 데이터베이스 연동
  - memory: 세션 메모리 관리

커스텀 MCP 서버:
  - bgg-api: BoardGameGeek API 전용
  - game-rules: 게임 규칙 파싱
```

## 3. 시스템 아키텍처 (상세 명세)

### 3.1 전체 시스템 구조
```
table_game_mate/
├── core/
│   ├── game_master.py          # 중앙 오케스트레이터
│   ├── agent_base.py           # Agent 기본 클래스
│   └── llm_client.py           # LLM 클라이언트 래퍼
├── agents/
│   ├── game_analyzer.py        # 게임 분석 Agent
│   ├── rule_parser.py          # 규칙 파싱 Agent
│   ├── player_manager.py       # 플레이어 관리 Agent
│   ├── persona_generator.py    # 페르소나 생성 Agent
│   ├── game_referee.py         # 심판 Agent
│   ├── score_calculator.py     # 점수 계산 Agent
│   └── player_agent.py         # 개별 플레이어 Agent
├── models/
│   ├── game_state.py           # 게임 상태 모델
│   ├── persona.py              # 페르소나 모델
│   └── game_rules.py           # 규칙 모델
├── mcp_servers/
│   ├── bgg_api_server.py       # BGG API MCP 서버
│   └── game_rules_server.py    # 게임 규칙 MCP 서버
├── utils/
│   ├── game_factory.py         # 게임 팩토리
│   ├── mcp_client.py           # MCP 클라이언트
│   └── validators.py           # 검증 유틸리티
├── ui/
│   ├── streamlit_app.py        # Streamlit 인터페이스
│   └── components/             # UI 컴포넌트
└── tests/
    ├── test_agents.py          # Agent 테스트
    ├── test_integration.py     # 통합 테스트
    └── test_games/             # 게임별 테스트
```

```
테이블게임 메이트 시스템
├── 사용자 인터페이스 (Streamlit/FastAPI)
├── 게임 마스터 에이전트 (LangGraph)
│   ├── 게임 검색 & 분석 에이전트
│   ├── 규칙 파서 & 검증 에이전트
│   ├── 플레이어 생성 매니저
│   ├── 페르소나 부여 에이전트
│   └── 게임 상태 관리자
├── 동적 플레이어 풀 (런타임 생성)
│   ├── 플레이어 에이전트 1-N
│   └── 각 에이전트별 고유 페르소나
├── 게임 관리 시스템
│   ├── 심판 & 규칙 검증 에이전트
│   └── 점수 & 승부 계산 에이전트
└── 외부 리소스 (MCP 서버들)
    ├── BoardGameGeek API
    ├── 웹 검색 엔진
    ├── 게임 규칙 DB
    └── 로컬 파일시스템
```

### 3.2 에이전트별 역할 정의

#### 게임 마스터 에이전트 (중앙 오케스트레이터)
- **책임**: 전체 게임 세션 관리 및 에이전트 간 조정
- **기능**: 
  - 사용자 요청 처리
  - 게임 선택 및 초기화
  - 플레이어 에이전트 생성 지시
  - 게임 진행 순서 관리

#### 게임 검색 & 분석 에이전트
- **책임**: 게임 정보 수집 및 분석
- **기능**:
  - BGG API를 통한 게임 검색
  - 웹 검색을 통한 규칙 수집
  - 게임 메타데이터 추출 (플레이어 수, 소요시간, 복잡도)
  - 게임 특성 분석 (전략성, 운, 상호작용 레벨)

#### 규칙 파서 & 검증 에이전트
- **책임**: 게임 규칙 구조화 및 검증
- **기능**:
  - 자연어 규칙을 구조화된 데이터로 변환
  - 게임 액션 유효성 검증
  - 승리 조건 확인
  - 턴 순서 및 페이즈 관리

#### 플레이어 생성 매니저
- **책임**: 게임별 최적 플레이어 수 결정 및 생성
- **기능**:
  - 게임 권장 플레이어 수 분석
  - 사용자 설정에 따른 플레이어 수 조정
  - 플레이어 에이전트 동적 생성
  - 플레이어별 역할 할당

#### 페르소나 부여 에이전트
- **책임**: 게임별 특화된 AI 성격 생성
- **기능**:
  - 게임 특성 분석 (협력/경쟁, 전략/운, 단순/복잡)
  - 적합한 페르소나 타입 결정
  - 각 플레이어별 고유 성격 생성
  - 페르소나 간 밸런스 조정

#### 심판 & 규칙 검증 에이전트
- **책임**: 게임 액션 검증 및 분쟁 해결
- **기능**:
  - 플레이어 액션 유효성 검사
  - 규칙 위반 감지 및 경고
  - 모호한 상황 해석
  - 게임 상태 무결성 유지

#### 점수 & 승부 계산 에이전트
- **책임**: 게임 결과 계산 및 통계 관리
- **기능**:
  - 실시간 점수 계산
  - 승리 조건 확인
  - 게임 통계 수집
  - 플레이어 성과 분석

### 3.3 페르소나 시스템 설계

#### 게임 특성별 페르소나 매트릭스

| 게임 타입 | 페르소나 예시 | 특징 |
|----------|--------------|------|
| **전략 게임** (ex: 카탄) | 장기적 사고자, 리스크 테이커, 자원 최적화자 | 계획적, 분석적, 예측 중심 |
| **사회적 추론** (ex: 마피아) | 의심 많은 탐정, 거짓말 전문가, 순진한 시민 | 심리전, 관찰력, 설득 |
| **협상 게임** (ex: 디플로마시) | 강경 협상가, 윈윈 추구자, 기회주의자 | 외교적, 전술적, 적응적 |
| **덱빌딩** (ex: 도미니언) | 콤보 추구자, 엔진 빌더, 방해 전문가 | 시너지, 효율성, 타이밍 |

#### 페르소나 생성 알고리즘
1. **게임 특성 분석**: 복잡도, 상호작용 레벨, 운vs전략 비율
2. **페르소나 풀 생성**: 게임에 적합한 5-10개 후보 생성
3. **균형 조정**: 너무 유사하거나 극단적인 조합 방지
4. **개성 부여**: 각 에이전트별 고유한 말투와 전략 스타일

## 4. 구현 계획

### 4.1 Phase 1: 핵심 인프라 구축 (2-3주)

#### 개발 목표:
- LangGraph 기반 기본 에이전트 시스템 구축
- MCP 서버 통합 및 연동
- 간단한 게임으로 POC 검증

#### 주요 작업:
1. **프로젝트 셋업**
   - LangGraph + MCP 환경 구성
   - 기본 프로젝트 구조 설계
   - 테스트 환경 구축

2. **MCP 서버 통합**
   - BGG API MCP 서버 개발
   - Brave Search, Fetch, Filesystem MCP 연동
   - Memory, SQLite MCP 설정

3. **기본 에이전트 개발**
   - 게임 마스터 에이전트 기본 구조
   - 게임 검색 에이전트
   - 단순한 플레이어 에이전트


## 4. 구현 계획 (상세 명세)

### 4.1 Phase 1: 기본 Agent 인프라 (1-2주)

#### 목표: Agent 기본 구조와 LLM 연동 완성

#### 구체적 작업:
1. **Day 1-2: 프로젝트 셋업**
   ```bash
   # 프로젝트 구조 생성
   mkdir -p table_game_mate/{core,agents,models,mcp_servers,utils,ui,tests}
   
   # 의존성 설치
   pip install langgraph langchain-google-genai streamlit
   ```

2. **Day 3-4: 기본 Agent 클래스 구현**
   - `core/agent_base.py`: BaseAgent 클래스
   - `core/llm_client.py`: Gemini 2.5 Flash Lite 클라이언트
   - `utils/mcp_client.py`: MCP 서버 연결 클라이언트

3. **Day 5-7: 첫 번째 Agent 구현**
   - `agents/game_analyzer.py`: 완전한 Agent 구현
   - 실제 LLM 호출 및 MCP 연동
   - 단위 테스트 작성

4. **Day 8-10: 기본 워크플로우 테스트**
   - 간단한 게임(틱택토)으로 전체 플로우 검증
   - LangGraph 통합 테스트
   - 에러 처리 및 로깅

#### 완료 기준:
- [ ] BaseAgent 클래스가 perceive/reason/act/learn 사이클 완전 구현
- [ ] GameAnalyzerAgent가 실제 BGG API 데이터 분석 가능
- [ ] LangGraph 워크플로우가 에러 없이 실행
- [ ] 틱택토 게임 1회 완주 가능

### 4.2 Phase 2: 핵심 Agent들 구현 (2-3주)

#### 목표: 게임 진행에 필요한 모든 Agent 완성

#### 구체적 작업:
1. **Week 1: 규칙 처리 Agent**
   - `agents/rule_parser.py`: 자연어 규칙 → 구조화된 데이터
   - `agents/game_referee.py`: 액션 검증 및 규칙 적용
   - `models/game_rules.py`: 규칙 데이터 모델

2. **Week 2: 플레이어 관리 Agent**
   - `agents/player_manager.py`: 플레이어 생성/관리
   - `agents/persona_generator.py`: 페르소나 생성
   - `agents/player_agent.py`: 개별 플레이어 Agent

3. **Week 3: 게임 진행 Agent**
   - `agents/score_calculator.py`: 점수 계산
   - `core/game_master.py`: 전체 워크플로우 완성
   - 통합 테스트 및 디버깅

#### 완료 기준:
- [ ] 모든 Agent가 실제 LLM 기반 추론 수행
- [ ] 3-4개 다른 타입 게임 지원 (전략/카드/보드)
- [ ] Agent 간 상호작용 및 데이터 전달 완전 동작
- [ ] 사용자가 채팅으로 게임 참여 가능

### 4.3 Phase 3: 페르소나 시스템 고도화 (1-2주)

#### 목표: 게임별 특화 AI 성격 시스템 완성

#### 구체적 작업:
1. **페르소나 생성 알고리즘**
   ```python
   # 게임별 페르소나 매트릭스
   GAME_PERSONA_MATRIX = {
       "strategy": ["analyzer", "risk_taker", "resource_optimizer"],
       "social": ["detective", "liar", "innocent"],
       "negotiation": ["diplomat", "hardliner", "opportunist"]
   }
   ```

2. **동적 페르소나 생성**
   - 게임 특성 자동 분석
   - 밸런스 조정 알고리즘
   - 페르소나 간 상호작용 모델링

3. **학습 시스템**
   - Agent별 전략 학습
   - 상대방 패턴 분석
   - 적응적 행동 변화

#### 완료 기준:
- [ ] 동일 게임도 매번 다른 페르소나 조합 생성
- [ ] Agent들이 서로 다른 전략과 말투로 플레이
- [ ] 게임 진행하며 Agent 행동 패턴 학습/변화
- [ ] 사용자가 Agent 성격 차이를 명확히 인식

### 4.4 Phase 4: UI 및 사용자 경험 (1주)

#### 목표: 직관적이고 재미있는 사용자 인터페이스

#### 구체적 작업:
1. **Streamlit 인터페이스**
   - 게임 선택 및 설정 페이지
   - 실시간 게임 진행 화면
   - 채팅 인터페이스

2. **게임 시각화**
   - 게임 상태 실시간 표시
   - Agent 행동 로그
   - 점수 및 통계 대시보드

#### 완료 기준:
- [ ] 사용자가 웹에서 게임 선택 후 바로 플레이 가능
- [ ] Agent들의 대화와 행동이 실시간으로 표시
- [ ] 게임 진행 상황을 직관적으로 파악 가능

### 4.5 Phase 5: 테스트 게임 확장 (1-2주)

#### 목표: 다양한 타입의 게임 지원 검증

#### 테스트 게임 목록:
1. **간단한 게임**: 틱택토, 가위바위보
2. **카드 게임**: UNO, 포커
3. **전략 게임**: 체커, 오델로
4. **사회적 게임**: 마피아 (간단 버전)
5. **복잡한 게임**: 카탄 (기본 규칙)

#### 완료 기준:
- [ ] 각 게임별로 적절한 페르소나 생성
- [ ] 규칙 위반 없이 게임 완주
- [ ] 사용자가 재미있게 플레이 가능
- [ ] Agent들이 합리적인 전략으로 플레이

## 5. 성공 지표 (구체적 측정 기준)

### 5.1 기술적 성공 지표
- **Agent 자율성**: 사용자 개입 없이 게임 80% 이상 진행
- **LLM 활용도**: 모든 의사결정에 LLM 추론 사용 (100%)
- **규칙 준수율**: 규칙 위반 발생률 5% 미만
- **시스템 안정성**: 10게임 연속 에러 없이 완주

### 5.2 사용자 경험 지표
- **게임 완주율**: 시작한 게임의 85% 이상 완주
- **Agent 구분도**: 사용자가 Agent별 성격 차이 인식 (설문 4/5 이상)
- **재미 요소**: "다시 하고 싶다" 응답 80% 이상
- **학습 효과**: Agent 행동이 게임 진행하며 변화 (관찰 가능)

### 5.3 시스템 성능 지표
- **응답 시간**: Agent 턴당 평균 10초 이내
- **메모리 사용량**: 게임당 500MB 이하
- **동시 세션**: 3개 게임 동시 진행 가능

## 6. 위험 요소 및 대응 방안

### 6.1 기술적 위험
1. **LLM 비용 초과**
   - 대응: 프롬프트 최적화, 캐싱 시스템
   - 예산: 개발 기간 중 $200 한도

2. **Agent 간 무한 루프**
   - 대응: 턴 제한, 타임아웃 설정
   - 최대 턴 수: 게임당 200턴

3. **규칙 파싱 실패**
   - 대응: 단계적 복잡도 증가
   - 폴백: 간단한 게임부터 시작

### 6.2 개발 위험
1. **일정 지연**
   - 대응: 주간 체크포인트
   - 우선순위: 핵심 기능 먼저 완성

2. **Agent 품질 저하**
   - 대응: 지속적 테스트
   - 기준: 매일 최소 1개 게임 완주 테스트

## 7. 최종 검증 시나리오

### 7.1 시스템 완성도 테스트
```
사용자 시나리오:
1. "카탄 게임을 3명이서 하고 싶어"
2. 시스템이 자동으로 게임 분석 및 AI 플레이어 2명 생성
3. 각 AI가 서로 다른 성격으로 플레이
4. 사용자가 채팅으로 참여하여 게임 완주
5. 최종 점수 및 통계 확인
```

### 7.2 Agent 품질 테스트
```
Agent 평가 기준:
1. 각 Agent가 고유한 전략과 말투 보여주는가?
2. 게임 진행하며 학습하고 적응하는가?
3. 규칙을 정확히 이해하고 준수하는가?
4. 사용자와 자연스럽게 상호작용하는가?
```

이 상세 명세를 바탕으로 개발하면 "Agent 빙자한 폴백 코드"가 아닌 **진짜 Agent 시스템**을 구축할 수 있습니다. 